1.
（1）1969年：
UNIX 操作系统由肯•汤普森（Ken Thompson）和丹尼斯•里奇（Dennis Ritchie）发明，都是贝尔实验室的
肯•汤普森（Ken Thompson）搞出了UNIX，丹尼斯•里奇（Dennis Ritchie）搞出了C语言，系统和语言，密不可分
（2）漫长的UNIX非开源时期，政府限制，高校内部流传
①加州大学 UNIX的BSD发布版本
②AT&T不再垄断，获准销售，UNIX的SystemV发布版本
（3）1984年：
理查德·马修·斯托曼（Richard Matthew Stallman）自由软件运动的精神领袖、
GNU计划以及自由软件基金会（Free Software Foundation）的创立者、著名黑客
（4）GNU被很多人认可，开发出很多可以再UNIX上使用的软件、工具、但是缺少一个系统内核
（5）1991年：
雷纳斯（Linus Torvalds），自己搞了一个类似UNIX操作系统内核，基本功能都有，非常好用，发明了“Linux”。
（6）不断迭代更新，2003年12月，发布了Linux内核2.6

2.
Linux内核版本，只是指Linus Torvalds和其他人所开发出的内核
Linux发行版，内核版本，没有软件，需要用户自己安装，自己创建文件系统，很费事，给发行商带来了商机
Linux发行版，最早出现于1992年，Ubuntu发行版问世于2004年

3.
linux内核职责：
（1）进程调度：属于抢占式多任务操作系统，多进程同时驻留于内存，“抢占”CPU的使用权
（2）内存管理：虚拟内存机制
①进程与进程之间、进程与内核之间彼此隔离，无法修改其它进程或内核的内存内容
②只需要将进程的一部分保持在内存中
（3）提供了文件系统
（4）创建和终止进程
（5）对设备的访问
（6）联网
（7）提供系统调用应用编程接口（API）
此外，linux是多用户的，同时可以供多人使用，互不影响。

4.
可移植文件名字符集[-._a-zA-Z0-9]  1+1+1+26+26+10  一共65个字符
int main(int argc, char *argv[])

5.
进程间通信（IPC）机制
①信号（signal），用来表示事件的发生
②管道（亦即shell用户所熟悉的"|"操作符）和FIFO，用于在进程间传递数据
③套接字，供同一台主机或是联网的不同主机上所运行的进程之间传递数据
④文件锁定，为防止其他进程读取或更新文件内容，允许某进程对文件的部分区域加以锁定
⑤消息队列，用于在进程间交换信息（数据包）
⑥信号量（semaphore），用来同步进程动作
⑦共享内存，允许两个及以上的进程共享一块内存。当某进程改变了共享内存的内容时，其他所有进程会立即了解到变化

6.
sudo apt-get install ros-kinetic-librealsense 
E: 无法获得锁 /var/lib/dpkg/lock-frontend - open (11: 资源暂时不可用)
E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?
sudo rm /var/cache/apt/archives/lock 
sudo rm /var/lib/dpkg/lock

7.
下载: src.3e.tar.gz（http://www.apuebook.com）
解压: tar xvf src.3e.tar.gz
安装相应库: sudo apt-get install libbsd-dev
进入到apue.3e目录，执行: make
cp ./include/apue.h /usr/include/
cp ./lib/libapue.a /usr/local/lib/
执行make
编译时链接到相应库: gcc -o 1-1 1-1.c -l apue

8.
所有shell都为其打开3个文件描述符
①标准输入（0，standard input）、②标准输出（1，standard output）、③标准错误（2，standard error）
比如：ls > file.list 可以吧ls的内容重定向到file.list文件中
,/mycat > data			把输出重定向到data
文件结束符：Ctrl+D
./mycat < date > fuck	把输入重定向到data，同时把输出重定向到fuck

9.
#include <sys/wait.h>
3个用于进程控制的主要函数：fork、exec（execlp）、waitpid
strerror(EACCES);			基于EACCES产生一条错误信息
erron = ENOENT;
perroe(argv[0]);			基于当前的erron产生错误信息

10.
键盘上产生信号的两种方法
中断键(interrupt key)：Delete或Ctrl+C
退出键(quit key)：Ctrl+\

11.
日历时间（time_t）：自1970.1.1 00:00:00的时间
进程时间（clock_t）：
（1）时钟时间：进程运行的时间总量
（2）用户CPU时间：执行用户指令所用的时间
（3）系统CPU时间：为该进程执行内核程序所经历的时间

12.
#include <unistd.h>
long sysconf(int name);
long pathconf(const char *pathname, int name);
long fpathconf(int fd, int name);
（1）与文件或目录无关的运行时选项用sysconf函数来判断
（2）与文件或目录有关的运行时选项通过调用pathconf或fpathconf函数来判断

13.
#include <fcntl.h>
(1)
int open(const char *path, int oflag, ... /* mode_t mode */);
int openat(int fd, const chat *path, int oflag, ... /* mode_t mode */);
oflag：
只指定一个：O_RDONLY（只读打开）O_WRONLY（只写打开）O_RDWR（读写打开）O_EXEC（只执行打开）O_SEARCH（只搜索打开，用于目录）
O_APPEND、O_CREAT、O_DIRECTORY、O_SYNC等，详见头文件
两个函数返回值相同，若成功，返回文件描述符，若出错返回-1
(2)
int creat(const char *path, mode_t mode);
若成功，返回为只写打开的文件描述符，若出错，返回-1
等价于open(path, O_WRONLY|OCREAT|O_WRONLY|OCREAT|O_TRUNC, mode);
#include <unistd.h>
(3)
int close(int fd);
一个进程终止时，内核自动关闭它所有的打开文件。很多程序都利用了这一功能，而不显式地用close关闭打开文件。
(4)
除非以O_APPEND打开，否则偏移量为0
off_t lseek(int fd, off_t offset, int whence)
若成功，返回新的文件偏移量，若出错，返回-1
如果文件描述符指向一个管道、FIFO或网络套接字，返回-1，并将erron设置为ESPIPIE
whence为SEEK_SET，开始处加offset，为SEEK_CUR，当前位置加offset(可正负)，为SEEK_END，结尾处加offset(可正负)
(5)
ssize_t read(int fd, void *buf, size_t nbytes);
返回值：读到的字节数，若已到文件尾，返回0，如出错返回-1
(6)
ssize_t write(int fd, const void *buf, size_t nbytes);
返回值：若成功，返回已写的字节数，若出错，返回-1
(5)(6)对应有原子操作版本,先lseek，再read，write，只不过绑定为原子操作
ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);
ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);
(7)
int dup(int fd);						// 新的描述符，一定是可用的最小值  
等同：fcntl(fd,F_DUPFD,0)
int dup2(int fd, int fd2);				// 如果fd2已经打开，则先关闭掉，然后重新指向
等同：close(fd2);  fcntl(fd,F_DUPFD,fd2);   // 这样就不是原子操作啦
两个函数的返回值：若成功，返回新的文件描述符，若出错，返回-1
注意：新的描述符，跟原来的描述符，指向同一个“文件表项”




