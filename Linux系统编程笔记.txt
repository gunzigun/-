1.
（1）1969年：
UNIX 操作系统由肯•汤普森（Ken Thompson）和丹尼斯•里奇（Dennis Ritchie）发明，都是贝尔实验室的
肯•汤普森（Ken Thompson）搞出了UNIX，丹尼斯•里奇（Dennis Ritchie）搞出了C语言，系统和语言，密不可分
（2）漫长的UNIX非开源时期，政府限制，高校内部流传
①加州大学 UNIX的BSD发布版本
②AT&T不再垄断，获准销售，UNIX的SystemV发布版本
（3）1984年：
理查德·马修·斯托曼（Richard Matthew Stallman）自由软件运动的精神领袖、
GNU计划以及自由软件基金会（Free Software Foundation）的创立者、著名黑客
（4）GNU被很多人认可，开发出很多可以再UNIX上使用的软件、工具、但是缺少一个系统内核
（5）1991年：
雷纳斯（Linus Torvalds），自己搞了一个类似UNIX操作系统内核，基本功能都有，非常好用，发明了“Linux”。
（6）不断迭代更新，2003年12月，发布了Linux内核2.6

2.
Linux内核版本，只是指Linus Torvalds和其他人所开发出的内核
Linux发行版，内核版本，没有软件，需要用户自己安装，自己创建文件系统，很费事，给发行商带来了商机
Linux发行版，最早出现于1992年，Ubuntu发行版问世于2004年

3.
linux内核职责：
（1）进程调度：属于抢占式多任务操作系统，多进程同时驻留于内存，“抢占”CPU的使用权
（2）内存管理：虚拟内存机制
①进程与进程之间、进程与内核之间彼此隔离，无法修改其它进程或内核的内存内容
②只需要将进程的一部分保持在内存中
（3）提供了文件系统
（4）创建和终止进程
（5）对设备的访问
（6）联网
（7）提供系统调用应用编程接口（API）
此外，linux是多用户的，同时可以供多人使用，互不影响。

4.
可移植文件名字符集[-._a-zA-Z0-9]  1+1+1+26+26+10  一共65个字符
int main(int argc, char *argv[])

5.
进程间通信（IPC）机制
①信号（signal），用来表示事件的发生
②管道（亦即shell用户所熟悉的"|"操作符）和FIFO，用于在进程间传递数据
③套接字，供同一台主机或是联网的不同主机上所运行的进程之间传递数据
④文件锁定，为防止其他进程读取或更新文件内容，允许某进程对文件的部分区域加以锁定
⑤消息队列，用于在进程间交换信息（数据包）
⑥信号量（semaphore），用来同步进程动作
⑦共享内存，允许两个及以上的进程共享一块内存。当某进程改变了共享内存的内容时，其他所有进程会立即了解到变化

6.
sudo apt-get install ros-kinetic-librealsense 
E: 无法获得锁 /var/lib/dpkg/lock-frontend - open (11: 资源暂时不可用)
E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?
sudo rm /var/cache/apt/archives/lock 
sudo rm /var/lib/dpkg/lock

7.
下载: src.3e.tar.gz（http://www.apuebook.com）
解压: tar xvf src.3e.tar.gz
安装相应库: sudo apt-get install libbsd-dev
进入到apue.3e目录，执行: make
cp ./include/apue.h /usr/include/
cp ./lib/libapue.a /usr/local/lib/
执行make
编译时链接到相应库: gcc -o 1-1 1-1.c -l apue

8.
所有shell都为其打开3个文件描述符
①标准输入（0，standard input）、②标准输出（1，standard output）、③标准错误（2，standard error）
比如：ls > file.list 可以吧ls的内容重定向到file.list文件中
,/mycat > data			把输出重定向到data
文件结束符：Ctrl+D
./mycat < date > fuck	把输入重定向到data，同时把输出重定向到fuck
5<>temp.foo 表示在文件描述符5上打开文件temp.foo以供读、写
2>>temp.foo 表示在文件描述符2上打开文件temp.foo以供追加、写

9.
#include <sys/wait.h>
3个用于进程控制的主要函数：fork、exec（execlp）、waitpid
strerror(EACCES);			基于EACCES产生一条错误信息
erron = ENOENT;
perroe(argv[0]);			基于当前的erron产生错误信息

10.
键盘上产生信号的两种方法
中断键(interrupt key)：Delete或Ctrl+C
退出键(quit key)：Ctrl+\

11.
日历时间（time_t）：自1970.1.1 00:00:00的时间
进程时间（clock_t）：
（1）时钟时间：进程运行的时间总量
（2）用户CPU时间：执行用户指令所用的时间
（3）系统CPU时间：为该进程执行内核程序所经历的时间

12.
#include <unistd.h>
long sysconf(int name);
long pathconf(const char *pathname, int name);
long fpathconf(int fd, int name);
（1）与文件或目录无关的运行时选项用sysconf函数来判断
（2）与文件或目录有关的运行时选项通过调用pathconf或fpathconf函数来判断
------------------------------------------------------------------------------------------------
13.文件I/O
#include <fcntl.h>
(1)
int open(const char *path, int oflag, ... /* mode_t mode */);
int openat(int fd, const chat *path, int oflag, ... /* mode_t mode */);
oflag：
只指定一个：O_RDONLY（只读打开）O_WRONLY（只写打开）O_RDWR（读写打开）O_EXEC（只执行打开）O_SEARCH（只搜索打开，用于目录）
O_APPEND、O_CREAT、O_DIRECTORY、O_SYNC等，详见头文件
两个函数返回值相同，若成功，返回文件描述符，若出错返回-1
(2)
int creat(const char *path, mode_t mode);
若成功，返回为只写打开的文件描述符，若出错，返回-1
等价于open(path, O_WRONLY|OCREAT|O_WRONLY|OCREAT|O_TRUNC, mode);
#include <unistd.h>
(3)
int close(int fd);
一个进程终止时，内核自动关闭它所有的打开文件。很多程序都利用了这一功能，而不显式地用close关闭打开文件。
(4)
除非以O_APPEND打开，否则偏移量为0
off_t lseek(int fd, off_t offset, int whence)
若成功，返回新的文件偏移量，若出错，返回-1
如果文件描述符指向一个管道、FIFO或网络套接字，返回-1，并将erron设置为ESPIPIE
whence为SEEK_SET，开始处加offset，为SEEK_CUR，当前位置加offset(可正负)，为SEEK_END，结尾处加offset(可正负)
(5)
ssize_t read(int fd, void *buf, size_t nbytes);
返回值：读到的字节数，若已到文件尾，返回0，如出错返回-1
(6)
ssize_t write(int fd, const void *buf, size_t nbytes);
返回值：若成功，返回已写的字节数，若出错，返回-1
(5)(6)对应有原子操作版本,先lseek，再read，write，只不过绑定为原子操作
ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);
ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);
(7)
int dup(int fd);						// 新的描述符，一定是可用的最小值  
等同：fcntl(fd,F_DUPFD,0)
dup(0)等同：open("/dev/fd/0", mode)
int dup2(int fd, int fd2);				// 如果fd2已经打开，则先关闭掉，然后重新指向
等同：close(fd2);  fcntl(fd,F_DUPFD,fd2);   // 这样就不是原子操作啦
两个函数的返回值：若成功，返回新的文件描述符，若出错，返回-1
注意：新的描述符，跟原来的描述符，指向同一个“文件表项”
(8)
void sync(void);	linux系统的守护进程update，周期性（一般是30秒）调用这个函数，来冲洗内核的块缓冲区
int fsync(int fd);		只对指定的一个文件生效，用于数据库这样的应用程序，需要确保修改过的块立刻写到磁盘上
int fdatasync(int fd);		类似于fsync，但是只影响文件的数据部分，fsync，还会更新文件属性
#include <fcntl.h>
(9)
int fcntl(int fd, int cmd, ... /* int arg */);    出错返回-1
cmd = F_DUPFD/F_DUPFD_CLOEXEC     复制一个已有的描述符
cmd = F_GETFD/F_SETFD			  获取/设置文件描述符标志(FD_CLOEXEC)
cmd = F_GETFL/F_SETFL			  获取/设置文件状态标志(O_APPEND、O_NONBLOCK、O_*SYNC可以更改，其它不行)
cmd = F_GETOWN/F_SETOWN			  获取/设置异步I/O所有权
cmd = F_GETLK/F_SETLK/F_SETLKW	  获取/设置记录锁
其中：当前只定义了一个文件描述符标志FD_CLOEXEC
0： exec时不关闭已经打开的文件描述符
1： exec时关闭已经打开的文件描述符
---------------------------------------------------------------------------------------------------------
14.文件和目录
(1)查看文件结构
#include <sys/stat.h>
int stat(const char *restrict pathname, struct stat *restrict buf);
int fstat(int fd, struct stat *buf);
int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag);
用于返回文件有关的信息结构
int lstat(const char *restrict pathname, struct stat *restrict buf);
这大体相同，不过当文件名是一个“符号链接”时，返回的是符号链接有关的信息
mode_t umask(mode_t cmask);		//返回原来的屏蔽字（用户、组、读、写、执行这些）
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
int fchmodat(int fd, const char *pathname, mode_t mode, int flag);
(2)文件类型
S_ISREG()普通文件、S_ISDIR()目录文件、S_ISCHR()字符特殊文件、S_ISBLK()块特殊文件、S_ISFIFO()管道或FIFO、
S_ISLNK()符号链接、S_ISSOCK()套接字
(3)设置用户ID程序/设置用户组ID程序
set-user-ID和set-group-ID
比如：passwd是一个设置用户ID程序，所有者是root。所有任何进程执行passwd有超级用户权限
(4)
目录的读权限：可以获得目录中所有文件名的列表
目录的执行权限：使我们可以搜索该目录，寻找一个指定的文件名（$PATH中某路径无执行权限，则找不到该目录的可执行文件）
(5)
#include <unistd.h>
int access(const char *pathname, int mode);		// mode = R_OK|W_OK|X_OK
int faccessat(int fd, const char *pathname, int mode, int flag);
这两个函数按照实际用户的ID和实际组ID进行访问权限设置
当flag为AT_EACCESS时，访问检查调用进程的有效用户ID和有效组ID，而不是实际用户ID和实际组ID
(6)
int chown(const char *pathname, uid_t owner, gid_t group);
int fchown(int fd, uid_t owner, gid_t group);
int fchownat(int fd, const char *pathname, uid_t owner, gid_t group, int flag);
int lchown(const char *pathname, uid_t owner, gid_t group);
如果是“符号链接”，lchown和fchownat（设置了AT_SYMLINK_NOFOLLOW）更改的是链接本身的所有者，而不是对应文件的所有者
(7)将文件长度截断为length
int truncate(const char *pathname, off_t length);
int ftruncate(int fd, off_t length);
(8)添加链接（硬链接），去除链接
int link(const char *existingpath, const chat *newpath); // 不允许构造指向目录的硬链接
int linkat(int efd, const char *existingpath, int nfd, const char *newpath, int flag);
int unlink(const char *pathname);
int unlinkat(int fd, const char *pathname, int flag);
(9)创建和读取链接（软链接）
int symlink(const char *actualpath, const char *sympath);
int symlinkat(const char *actualpath, int fd, const char *sympath);
ssize_t readlink(const char *restrict pathname, char *restrict buf, size_t bufsize);	//读取链接本身的内容
ssize_t readlinkat(int fd, const char *restrict pathname, char *restrict buf, size_t bufsize);
(10) 删除，重命名
#include <stdio.h>
int remove(const char *pathname);
int rename(const char *oldname, const char *newname);
int renameat(int oldfd, const char *oldname, int newfd, const char *newname);
(11)文件的时间：访问时间（st_atim）、修改时间（st_mtim）、状态更改时间（st_ctim）
#include <sys/stat.h>
int futimens(int fd, const struct timespec times[2]);  // times[2]包含访问时间、修改时间
int utimensat(int fd, const char *path, const struct timespec times[2], int flag);
(12)创建目录和删除目录   更改目录    获取完整路径
int mkdir(const char *pathname, mode_t mode);
int mkdirat(int fd, const char *pathname, mode_t mode);
int rmdir(const char *pathname);
int chdir(const char *pathname);
int fchdir(int fd);
char* getcwd(char *buf, size_t size);
(13)主从设备号
stat(argv[i], &buf);
printf("dev = %d/%d", major(buf.st_dev),  minor(buf.st_dev));   // st_dev表示设备号。用major和minor函数提取主、子设备号
if (S_ISCHR(buf.st_mode) || S_ISBLK(buf.st_mode)) 
{
	printf(" (%s) rdev = %d/%d", (S_ISCHR(buf.st_mode)) ? "character" : "block", major(buf.st_rdev), minor(buf.st_rdev));
}		// st_rdev表示设备号(字符特殊文件、块特殊文件)。用major和minor函数提取主、子设备号
---------------------------------------------------------------------------------------------------------
15.标准IO
(1)流的定向函数（单字节、多字节）
int fwide(FILE *fp, int mode);
(2)3种类型的缓冲
全缓冲：在填满标准I/O缓冲区后才进行实际I/O操作。
行缓冲：在输入和输出中遇到换行符时，标准I/O库执行I/O操作。
注意：每一行的缓冲区有限，如果填满了，即便尚未写入换行，也进行I/O操作
不带缓冲：不对字符进行缓冲存储
其中，设置缓冲的函数
void setbuf(FILE *restrict fp, char *restrict buf);			全缓冲或行缓冲
int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
mode = _IOFBF全/_IOLBF行/_IONBF无，size为指定缓冲区大小
(3)冲洗缓冲
int fflush(FILE *fp);
(4)打开一个标准I/O流，关闭一个标准I/O流
FILE *fopen(const char *restrict pathname, const char *restrict type);			//用某文件打开
FILE *fdopen(int fd, const chat *type)		// 从一个已有描述符打开，一般提供给管道，网络通信通道使用
FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
// 一般用于将一个指定的文件，打开为一个预定义的流：标准输入、标准输出、标准错误
FILE *fmemopen(void *restrict buf, size_t size, const char *restrict type);		
// 打开时，缓冲区第一个位置设置为null字节。此外，从内存打开一个流，流关闭，buf会被释放
// type 为 r、w、a等
      限制	              r		w	  a    r+    w+    a+
  文件必须已存在		  √                 √
放弃文件以前的内容              √                √
	流可以读              √                 √    √     √
	流可以写                    √     √     √    √     √
流只可以在为尾端写                    √                √
int fclose(FILE *fp);
int fileno(FILE *fp);		// 获取某个流的文件描述符
(5)输入、输出函数（一次一个）
int getc(FILE *fp);			宏
int fgetc(FILE *fp);		函数
int getchar(void);   等同于getc(stdin);
int ferror(FILE *fp);
int feof(FILE *fp);		//每个流在FILE对象中，维护两个标志，出错标志，文件结束标志
void clearerr(FILE *fp);		//清除上述标志
int ungetc(int c, FILE *fp);		// 把字符压回流中
int putc(int c, FILE *fp);
int fputc(int c, FILE *fp);
int putchar(int c);
(6)输入、输出函数（一次一行），效率高，因为用memcopy，而memcopy使用汇编语言编写，非C语言
char *fgets(char *restrict buf, int n, FILE *restrict fp);
char *gets(char *buf);
int fputs(const char *restrict str, FILE *restrict fp);
int puts(const char *str);
注意：每行中止处，自己处理换行符
(7)输入、输出（二进制, 数组，结构体等）
size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
(8)定位流
long ftell(FILE *fp);							// 文件当前位置距文件首的距离
int fseek(FILE *fp, long offset, int whence);	// 类似lseek
void rewind(FILE *fp);							// 将一个流设置到文件的起始位置
int fgetpos(FILE *restrict fp, fpos_t *restrict pos);
int fsetpos(FILE *fp, const fpos_t *pos);			// 这两个函数用于移植到非unix系统
(9)格式化输出
int printf(const char *restrict format, ...);
int fprintf(FILE *restrict fp, const char *restrict format, ...);
int dprintf(int fd, const char *restrict format, ...);
int sprintf(char *restrict buf, const char *restrict format, ...);
int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);
(10)格式化输入
int scanf(const char *restrict format, ...);
int fscanf(FILE *restrict fp, const char *restrict fromat, ...);
int sscanf(const char *restrict buf, const char *restrict format, ...);
(11)临时文件
char *tmpnam(char *ptr);
FILE *tmpfile(void);
char *mkdtemp(char *template);
int mkstemp(char *template);
