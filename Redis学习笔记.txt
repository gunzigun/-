make之前，chmod 777 mkreleasehdr.sh，会生成下列文件
redis-benchmark		// 性能测试工具
redis-check-aof		// AOF文件修复工具
redis-check-rdb		// RDB文件检查工具（快照持久化文件）
redis-cli			// 命令行客户端
redis-server		// redis服务器启动命令

./redis-server ***.conf				指定配置打开一个redis服务
./redis-server --port 6666 			指定端口号打开一个redis服务
./redis-cli -h 主机IP -p 端口号		连接指定的redis服务器

第一部分、数据结构与对象
(1)简单动态字符串
redis自己构建了一种名为简单动态字符串SDS的抽象类型，key就是这种类型
SET msg "hello world" : key是一个保存着"msg"的SDS对象，value是一个保存着"hello world"的SDS对象
RPUSH fruits "apple" "banana" "cherry" : key是一个保存着"fruits"的SDS对象，value保存着一个列表对象，内含三个SDS
此外，SDS还用做AOF中的缓冲区
struct sdshdr {
    int len;	 // buf 中已占用空间的长度，不包括'\0'
    int free;    // buf 中剩余可用空间的长度
    char buf[];  // 数据空间（字节数组，是二进制数据，不由'\0'来判断结束）
};
1.该结构的优点：
获取字符串长度O(1),而C数组获取字符串长度O(N)
字符串操作前，只要检测free和lenth就知道，缓冲区是否足够，这样子可以避免缓冲区溢出
由于free区的存在，整个SDS，不用反复的对数组空间进行分配、释放
内存的扩充策略：小于SDS_MAX_PREALLOC (1024*1024)，则翻倍+1，需要长度加上SDS_MAX_PREALLOC+1，+1是给"\0"的
惰性空间释放策略：因为字符串缩减后，保留着，用free记录
---------------------------------------------------------------------------------------------------------
(2)链表
1.LLEN key 							// 返回列表key的长度
2.RPUSH/LPUSH key [value...]		// 在列表的右边|左边加入元素
3.LRANGE key index-start index-end	// 返回列表key[index-start]~key[index-end]的所有元素
typedef struct listNode {
    struct listNode *prev;	// 前置节点
    struct listNode *next;	// 后置节点 
    void *value;			// 节点的值
} listNode;
typedef struct list {
	// 双端无环
    listNode *head;							// 表头节点
    listNode *tail;							// 表尾节点
	// 三个函数指针，用以实现多态，设定特定函数
    void *(*dup)(void *ptr);				// 节点值复制函数
    void (*free)(void *ptr);				// 节点值释放函数
    int (*match)(void *ptr, void *key);		// 节点值对比函数
    unsigned long len;						// 链表所包含的节点数量
} list;
--------------------------------------------------------------------------------------------------------------
(3)字典（符号表、关联数组、映射）：一种用于保存键值对的抽象数据结构
1.HLEN key 				// 获取一个哈希表的键值对个数
2.HGETALL key			// 获取一个哈希表中的所有键值
typedef struct dictEntry {
    void *key;							// 键
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;								// 值
    struct dictEntry *next;				// 指向下个哈希表节点，形成链表
} dictEntry;
typedef struct dictht {
    dictEntry **table;					// 哈希表数组
    unsigned long size;					// 哈希表大小
    unsigned long sizemask;				// 哈希表大小掩码，用于计算索引值，总是等于size - 1
    unsigned long used;					// 该哈希表已有节点的数量
} dictht;
typedef struct dictType {
    unsigned int (*hashFunction)(const void *key);							// 计算哈希值的函数
    void *(*keyDup)(void *privdata, const void *key);						// 复制键的函数
    void *(*valDup)(void *privdata, const void *obj);						// 复制值的函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);	// 对比键的函数
    void (*keyDestructor)(void *privdata, void *key);						// 销毁键的函数
    void (*valDestructor)(void *privdata, void *obj);						// 销毁值的函数
} dictType;
typedef struct dict {
    dictType *type;				// 类型特定函数
    void *privdata;				// 私有数据
    dictht ht[2];				// 哈希表ht[0]被使用，ht[1]在rehash时使用
    int rehashidx;  			// rehash 索引，当 rehash 不在进行时，值为 -1
    int iterators; 				// 目前正在运行的安全迭代器的数量
} dict;
hash = dict->type->hashFunction(k0);
index = hash & dict->ht[0].sizemask;  // 采用链地址发法，解决键冲突
3.rehash策略
收缩、扩展原则，都是：ht[1]大小为第一个大于或等于ht[0].used*2的（2的n次方幂）
然后ht[0]上的所有键值对，rehash到ht[1]上
释放ht[0],将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下次rehash做准备
4.何时收缩或扩展
负载因子load_factor = ht[0].used / ht[0].size
①未执行BGSAVE或者BGREWRITEAOF，负载因子>=1，扩展
②正在执行BGSAVE或者BGREWRITEAOF，负载因子>=5，扩展
③负载因子<0.1，收缩
5.rehash是渐进式的，数据很多时，一次性操作十分耗时，分摊到对字典的每个添加、删除、查找操作上，
------------------------------------------------------------------------------------------------------------
(4)跳跃表
ZADD salary 2000 tom
ZADD salary 5000 jack		// 有序集合中添加两个成员，各自具有一个价值
ZCARD salary				// 有序集合的元素个数
ZRANGE salary index-start index-end [WITHSCORES]	// 输出有序集合的index-start到index-end，带有价值
在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的。
typedef struct zskiplistNode {
    robj *obj;							// 成员对象
    double score;						// 分值
    struct zskiplistNode *backward;		// 后退指针
    struct zskiplistLevel {				
        struct zskiplistNode *forward;	// 前进指针
        unsigned int span;				// 跨度
    } level[];							// 层(1-32的随机数)
} zskiplistNode;
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;	// 表头节点和表尾节点
    unsigned long length;					// 表中节点的数量
    int level;								// 表中层数最大的节点的层数
} zskiplist;								
---------------------------------------------------------------------------------------------------------------
(5)整数集合
SADD numbers 1 3 5 7 9			// 创建一个集合，有5个元素
typedef struct intset {
    uint32_t encoding;		// 编码方式
    uint32_t length;		// 集合包含的元素数量
    int8_t contents[];		// 保存元素的数组
} intset;
虽然intset结构将contents属性声明为int8_t，实际上其类型由encoding决定
encoding=INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64，对应int16_t、int32_t、int64_t
存在升级操作，当一个新加入数是int64_t，其它数据也被升级到int64_t（节约内存），但是不再降级
该新加入元素，小于所有现有元素，放开头；新加入元素，大于所有现有元素，放结尾
--------------------------------------------------------------------------------------------------------------
(6)压缩列表（ziplist）
当一个列表键只包含少量列表项，并且每个列表要么就是小整数值，要么就是长度较短的字符串，那么就使用压缩列表来实现
RPUSH lst 1 3 5 10086 "hello" "world"
HMSET profile "name" "Jack" "age" 28 "job" "Programmer"		// 往一个列表中加入多个键值对
非空 ziplist 示例图

area        |<---- ziplist header ---->|<----------- entries ------------->|<-end->|

size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte
            +---------+--------+-------+--------+--------+--------+--------+-------+
component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |
            +---------+--------+-------+--------+--------+--------+--------+-------+
                                       ^                          ^        ^
address                                |                          |        |
                                ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END
                                                                  |
                                                        ZIPLIST_ENTRY_TAIL
*/
typedef struct zlentry {
    // prevrawlen ：前置节点的长度; prevrawlensize ：编码 prevrawlen 所需的字节大小
    unsigned int prevrawlensize, prevrawlen;
    unsigned int lensize, len;			// len ：当前节点值的长度; lensize ：编码 len 所需的字节大小
    unsigned int headersize;			// 当前节点 header 的大小; 等于 prevrawlensize + lensize
    unsigned char encoding;				// 当前节点值所使用的编码类型
    unsigned char *p;					// 指向当前节点的指针
} zlentry;
上述紧凑的结构，对压缩链表的增加元素、删除元素，将引发连锁更新
--------------------------------------------------------------------------------------------------------------
(7)对象
Redis并没有直接使用(1)-(6)的数据结构来实现键值对数据库，而是基于这些数据结构，创建了一个对象系统。
其中包含对象有：字符串对象、列表对象、哈希对象、集合对象、有序集合对象
此外，Redis对象系统还实现了，基于引用计数的内存回收机制，当程序不再使用某个对象时，对象所占用的内存会被自动释放
typedef struct redisObject {
    unsigned type:4;				// 类型
    unsigned encoding:4;			// 编码
    unsigned lru:REDIS_LRU_BITS; 	// 对象最后一次被访问的时间
    int refcount;					// 引用计数
    void *ptr;						// 指向实际值的指针
} robj;
对于数据库保存的键值对来说，键总是一个字符串对象，而值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象
type = REDIS_STRING、REDIS_LIST、REDIS_HASH、REDIS_SET、REDIS_ZSET
TYPE msg		// 指令返回msg键，对应值的对象类型（string、list、hash、set、zset）
encoding 类型定义如下
#define REDIS_ENCODING_RAW 0     /* Raw representation 简单动态字符串*/		<->REDIS_STRING
#define REDIS_ENCODING_INT 1     /* Encoded as integer long类型整数*/	<->REDIS_STRING
#define REDIS_ENCODING_HT 2      /* Encoded as hash table 字典*/	<->REDIS_HASH、REDIS_SET
#define REDIS_ENCODING_ZIPMAP 3  /* Encoded as zipmap 其实质是用一个字符串数组来依次保存key和value*/
#define REDIS_ENCODING_LINKEDLIST 4 /* Encoded as regular linked list 双端链表*/	<->REDIS_LIST
#define REDIS_ENCODING_ZIPLIST 5 /* Encoded as ziplist 压缩列表*/	<->REDIS_LIST、REDIS_HASH、REDIS_ZSET
#define REDIS_ENCODING_INTSET 6  /* Encoded as intset 整数集合*/	<->REDIS_SET
#define REDIS_ENCODING_SKIPLIST 7  /* Encoded as skiplist 跳跃表和字典*/	<->REDIS_ZSET
#define REDIS_ENCODING_EMBSTR 8  /* Embedded sds string encoding embstr编码的简单动态字符串*/	<->REDIS_STRING
OBJECT ENCODING msg	
//指令返回msg键，对应值的编码类型（int、embstr、raw、hashtable、linkedlist、ziplist、intset、skiplist）
//以上type和encoding的实现，极大地提升了Redis的灵活性和效率
OBJECT REFCOUNT msg		// 返回对象的引用计数
OBJECT IDLETIME	msg		// 返回对象有多久没被使用过了
1.字符串对象（string）：可以使用int，raw，embstr来实现
embstr实现将raw实现的中两次分配操作（redisObject和sdshdr），合并为一次，内存是连续的，提高了效率
对embstr字符串执行任何修改命令时，程序会先将对象编码从embstr->raw
SET、GET、APPEND、INCRBYFLOAT、INCRBY、DECRBY、STRLEN、
SETRANGE key offset value、GETRANGE key start end
2.列表对象（list）：可以使用ziplist或者linkedlist来实现
①列表对象保存的所有字符串元素的长度都小于64字节  &  ②列表对象保存的元素数量小于512，才使用ziplist实现
上限值可修改，在list-max-ziplist-value和list-max-ziplist-entries
当加入元素后，不满足①②条件，则转换成linkedlist编码
LPUSH、RPUSH、LPOP、RPOP、LINDEX key index、LLEN、LINSERT key BEFORE|AFTER pivot(轴元素) value、
LREM key count value、LTRIM key start stop、LSET
3.哈希对象（hash）：可以使用ziplist或者hashtable来实现
如果以ziplist编码：调用三次HSET，加入3个键值对后，压缩链表内key1,value1,key2,value2,key3,value3保存了6个元素
①哈希对象保存的所有键值对的键和值的长度都小于64字节  &  ②哈希对象保存的键值对数量小于512，才使用ziplist实现
上限值可修改，在hash-max-ziplist-value和hash-max-ziplist-entries
当加入元素后，不满足①②条件，则转换成hashtable编码
HSET hash field value、HGET hash field、HEXISTS hash field、HDEL hash field [field …]、HLEN、HGETALL
4.集合对象（set）：可以使用intset或者hashtable来实现
①集合对象保存的所有元素都是整数值	& ②集合对象保存的元素数量不超过512个， 才使用intset实现
上限值可修改，set-max-intset-entries
当加入元素后，不满足①②条件，则转换成hashtable编码
SADD、SCARD（返回元素数量）、SISMEMBER、SMEMBERS、SRANDMEMBER、SPOP（随机删除一个元素并返回）、SREM key member
5.有序集合对象（zset）：可以使用ziplist或者skiplist来实现
如果使用ziplist编码：压缩链表保存成员1，分值1，成员2，分值2
如果使用skiplist编码
typedef struct zset {
	zskiplist *zsl;
	dict *dict;			//保存成员到分值的映射
} zset;
虽然既有跳跃表，又有字典，但是数据不重复，因为通过指针共享相同的成员和分值
①有序集合保存的元素数量小于128个 & ②有序集合保存的所有元素成员的长度都小于64字节，才使用ziplist实现
上限值可修改，在zset-max-ziplist-value和zset-max-ziplist-entries
当加入元素后，不满足①②条件，则转换成skiplist编码
ZADD key score member [[score member] [score member] …]、ZCARD key（返回元素数量）、ZCOUNT key min max（值范围内元素）、
ZRANGE key start stop [WITHSCORES]（index范围内递增）、ZREVRANGE key start stop [WITHSCORES]（index范围内递减）、
ZRANK key member（成员的正向排名）、ZREVRANK key member（成员的逆向排名）、
ZREM key member、ZSCORE key member
-----------------------------------------------------------------------------------------------------------------
(8)对象的使用
1.Redis中用于操作键的命令基本上可以分为两种类型：
①可对任何键
DEL删除、EXPIRE key seconds设置自动过期时间、RENAME重命名、TYPE类型、OBJECT命令等
②只能对特定类型的键：见（7）中描述，Redis在执行前会先做类型检查
2.内存回收
typedef struct redisObject {
	...
    int refcount;					// 引用计数
} robj;
创建一个新对象时，引用refcount初始化为1，被新程序使用+1，不在被一个程序使用-1，变为0时，释放
3.对象共享（只对包含整数值的字符串对象进行共享0-9999，不然判断相同太耗时了）
将数据库键的值指针指向一个现有的值对象，被共享的值对象的引用计数+1
创建共享字符串对象的数量可以通过修改redis.h/REDIS_SHARED_INTEGERS常量来修改
-----------------------------------------------------------------------------------------------------------------
第二部分、单机数据库的实现
(1)数据库
1.Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，每一项都是redis.h/redisDb结构
struct redisServer{
	// ...
	redisDb *db;			// 保存着服务器中所有数据库的数组
	int	dbnum;				// 服务器的数据库数量，由配置的databases选项决定
	// ...
};
2.切换数据库 SELECT index（0~databases-1）
在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库
typedef struct redisClient{
	// ...
	redisDb *db;		// 指向当前select的数据库
	// ...
} redisClient;
为了避免对数据库进行误操作，在执行Redis命令特别是像FLUSHDB（清空）这样危险命令之前，最好先执行一个SELECT命令，显示切换一下
3.数据库键空间
typedef struc redisDb{
	// ...
	dict *dict;	// 数据库键空间，保存着数据库中的所有键值对
	// ...
} redisDb;
RANDOMKEY			// 随机返回一个key
KEYS pattern(*)		// 按照某种模式返回keys
INFO stats			// 查看数据库的属性
4.设置键的过期时间
TIME								// 获取UNIX时间戳
EXPIRE/PEXPIRE key seconds 			// 以秒/毫秒设置过期时间。seconds是多少时间后过期
EXPIREAT/PEXPIREAT key timestamp	// 命令用于将键key的过期时间设置为timestamp（秒级/毫秒级）
TTL/PTTL							// 以秒/毫秒返回键的过期时间
redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典
typedef struct redisDb{
	// ...
	dict *expires;			// 过期字典，保存着键的过期时间
	// ...
} redisDb;
过期字典的键是一个指针，指向键空间中的某个键对象（数据库键）
过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间，一个毫秒精度的时间戳
PERSIST				// 消除一个键的过期时间
5.过期键删除策略
被动删除：
【①惰性删除】，放任不管，每次从键空间取键时，检查键是否过期，过期就删除
缺点：对内存不友好，键已经过期了，仍然保留，又没有被访问的化，就会一直残留着，可以视为一种“内存泄漏”
主动删除：
②定时删除，设置过期时间时，创建一个定时器（timer），让定时器在键过期时间来临时，立即执行对键的删除操作
缺点：对CPU不友好，如果过期键比较多的话，要占用很长时间的CPU，在内存不紧张，CPU紧张时，对吞吐量造成很大影响
同时，还需要创建大量的定时器，【现阶段不现实】
【③定期删除】，每隔一段时间，程序对数据库进行一次检测，删除过期键
是①和②的折中，难点在于如何确定删除操作的时长和频率
太频繁，执行时间太长，退化为定时删除；执行太少，执行时间太短，退化为定时删除
6.过期键删除的实现：
【①惰性删除】：db.c/expireIfNeeded函数实现
每次数据库读写时，都会调用expireIfNeeded函数对键进行检查，过期删除，未过期不做动作
【③定期删除】：redis.c/activeExpireCycle函数实现
每当Redis服务周期性操作，redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用
在规定时间内，分多次遍历服务器中的各个数据库，随机检查并删除过期键
期间若果返回了，全局变量保存当前检查到的数据库[0]，下次调用activeExpireCycle接着从这个数据库[0]删
若检查到了数据库个数上限[15]，那么返回数据库[0]中删键
7.RDB持久化、AOF持久化和复制功能对过期键的处理
①RDB持久化中：
SAVE或者BGSAVE时，创建新的RDB文件，过期的键不会被保存
RDB载入时：服务器以主服务器模式运行，过期键会被忽略，不载入，以从服务器模式运行时，都会被载入，不过主从同步时，问题会消除，没影响
②AOF持久化中：
当过期键被惰性删除或者定期删除后，程序会向AOF文件追加一条，DEL命令，来显示的记录该键已被删除
生成AOF文件时，与生成RDB文件类似，过期键不会被保存
③复制模式：
服务器此模式下运行时，从服务器的过期键删除动作由主服务器控制。
保证数据一致性，就算从服务器有cli访问过期键，也不删除，必须等主服务器来同步。
8.数据库通知和订阅
redis> subscribe msg chat_room
Reading messages... (press Ctrl-C to quit)
1) "subscribe"       # 返回值的类型：显示订阅成功
2) "msg"             # 订阅的频道名字
3) (integer) 1       # 目前已订阅的频道数量
##############################################
1) "subscribe"
2) "chat_room"
3) (integer) 2
##############################################
1) "message"         # 返回值的类型：信息
2) "msg"             # 来源(从那个频道发送过来)
3) "hello moto"      # 信息内容
##############################################
1) "message"
2) "chat_room"
3) "testing...haha"
此外，
“某个键执行了什么命令”：键空间通知（key-space notification） SUBSCRIBE __keyspace@0__:message
“某个命令被什么键执行了”：键事件通知（key-event notification） SUBSCRIBE __keyevent@0__:del
发送通知，在notifiy.c/notifyKeyspaceEvent函数实现
----------------------------------------------------------------------------------------------------------------
(2)RDB持久化
SAVE	// 会阻塞Redis服务器进程，直到RDB文件创建完毕为止
BGSAVE	// 会fork一个子进程，然后由子进程负责RDB文件的创建，父进程继续处理命令请求
1.RDB文件的创建和写入
创建RDB文件，由rdb.c/rdbSave函数完成
AOF文件的更新频率比RDB文件的更新频率高，如果开启了AOF持久化功能，会优先使用AOF文件来还原文件
载入RDB文件，由rdb.c/rdbLoad函数完成
struct redisServer{
	// ...
	struct saveparam *saveparams;		// 记录了保存条件的数组，由conf文件配置
	long long dirty;					// 修改计数器（距离上次保存，进行了多少次修改）
	time_t lastsave;					// 上一次执行保存的时间
	// ...
};
struct saveparam{
	time_t seconds;		// 秒数
	int changes;		// 修改数
};										// seconds秒内，修改了changes次，则保存，调用BGSAVE
Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，查看条件是否满足，满足就BGSAVE
RDB文件结构
REDIS|db_version|【SELECTDB|0|pairs】|【SELECTDB|3|pairs】|EOF|check_sum
pairs中的一个: [EXPIRETIME_MS|ms] （有过期时间的键，可选）| 【TYPE|key|value】
2.查看RDB文件，od -c dump.rdb 
-----------------------------------------------------------------------------------------------------------------
(3)AOF持久化(Append Only File)
通过保存Redis服务器所执行的写命令来记录数据库状态的，即AOF文件里保存的是一条条指令
三个步骤：配置 appendonly yes
struct redisServer{
	// ...
	sds aof_buf;		// AOF缓冲区
	// ...
};
1.命令追加
SET key value，之后，在aof_buf缓冲区，追加内容：*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvlaue\r\n
2.文件写入 和 3.文件同步   flushAppendOnlyFile函数，行为由appendfsync配置决定
appendfsync always			// aof_buf所有内容写入，并同步到AOF文件，安全性最高，但是效率最慢，最多丢失一个命令数据
appendfsync everysec		// aof_buf所有内容写入，距离上次同步，必须超过一秒钟，才能同步，最多丢失一秒数据
appendfsync no				// aof_buf所有内容写入，并不同步，何时同步，由系统决定，容易丢失数据
// 以上所说的同步，是指系统缓存内容真正写入到磁盘中
4.启动之前，建立一个伪客户端，逐条执行保存下来的指令即可，还原回之前的状态
5.AOF文件的大小很容易膨胀：【解决办法-AOF文件重写】【BGREWRITEAOF】
BGREWRITEAOF，并不读原来的AOF文件，直接分析当前DB的状态，然后简化为一条新的命令，代替原来AOF中的多条命令
重写子进程在后台运行，这时候主进程可能还有收到写命令，这些命令需要同时加入到AOF重写缓冲区、AOF缓冲区
重写完毕，子进程告知父进程，父进程将重写缓冲区的内容写到新AOF文件中，然后把旧的AOF文件覆盖掉
-----------------------------------------------------------------------------------------------------------------
(4)事件
Reids服务器是一个事件驱动程序，主要有两类事件：【文件事件】、【时间事件】
1.文件事件：套接字、I/O多路复用程序、文件事件分派器、事件处理器（函数）
多路复用的代码，ae.h、ae.c、ae_epoll.c、ae_evport.c、ae_kqueue.c、ae_select.c
事件类型：AE_READABLE和AE_WRITABLE，优先处理可读事件
事件处理器（networking.c）：
连接应答处理器(acceptTcpHandler)、命令请求处理器(readQueryFromClient)、命令回复处理器(sendReplyToClient)
2.时间事件（id，when，timeProc）：定时事件（目前版本没有）、周期性事件
持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定的运行（serverCron函数）
serverCron函数，每间隔100毫秒运行一次（默认）。修改redis.conf中的hz选项来修改（每秒运行次数）
-----------------------------------------------------------------------------------------------------------------
(5)客户端
遍历clients链表来找到某个连接在服务器上的客户端
struct redisServer{
	// ...
	list *clients;		// 一个链表，保存了所有客户端状态（redisClient）
	// ...
};
typedef struct redisClient{
	// ...
	int fd;			// 文件描述符
	robj *name;		// 客户端名字
	int flags;		// 客户端类型、状态
	// ...	
} redisClient;	
【伪客户端】：fd的属性值为-1，伪客户端的命令请求来源于AOF文件或者Lua脚本，而不是网络
【普通客户端】：fd为大于-1的整数，用来与服务器通信。
CLIENT list查看连接到服务器上的客户端信息。
CLIENT setname xuguanglong 设置客户端的名称。
2.客户端请求命令，命令参数
typedef struct redisClient{
	// ...
	sds querybuf;	// 保存客户端发送的命令请求
	robj **argv;	// 是一个数组，数组中每一项是一个字符串对象，argv[0]是要执行的命令，之后的命令参数
	int argc;		// 记录argv的长度
	struct redisCommand *cmd;		// 见下面解释
	// ...	
} redisClient;
系统保存了一份命令表，键是一个SDS结构，保存了命令的名字，值是命令所对应的redisCommand结构，根据argv[0]找到对应的结构，让cmd指向之
3.输出缓冲区（指令的执行结果，保存在其中）
有两个缓冲区：
一个缓冲区大小固定（保存OK，简短字符串值等较小的回复）
typedef struct redisClient{
	// ...
	char buf[REDIS_REPLY_CHUNK_BYTES];			// 字节数组
	int bufpos;									// 保存buf数组目前已使用的字节数量
	// ...
} redisClient;
另一个缓冲区大小是可变的（如下），由reply链表和一个或多个字符串对象组成
typedef struct redisClient{
	// ...
	list *reply;				// 一个又一个StringObject，连接起来		
	// ...
} redisClient;
4.身份验证，上述结构中，还有一个int authenticated;字段  0表示未通过验证，1表示通过了验证
5.时间相关的属性
typedef struct redisClient{
	// ...
	time_t ctime;							// 记录了创建客户端的时间
	time_t lastinteraction;					// 记录了客户端与服务器最后一次进行互动（interaction）的时间
	time_t obuf_soft_limit_reached_time;	// 记录了输出缓冲区第一次到达软性限制（soft limit）的时间
	// ...
} redisClient;
6.配置项
硬性限制：如果输出缓冲区大小超过了硬性限制所设置的大小，那么立刻关闭客户端
软性限制：如果输出缓冲区大小超过了软性性限制所设置的大小，服务器，记录下该客户端达到软性限制的起始时间，如果在设置time范围内降下来了，就不关，并且obuf_soft_limit_reached_time也会被清零，从新计算。
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
第一行设置普通客户端的硬性限制和软性限制都为0，表示不限制客户端的输出缓冲区大小
第二行设置将从服务器客户端的硬性限制设置为256MB，软性限制设置为64MB，软性限制时长60秒
第三行设置将从服务器客户端的硬性限制设置为32MB，软性限制设置为8MB，软性限制时长60秒
-----------------------------------------------------------------------------------------------------------------
(6)服务器
第三部分、多机数据库的实现
(1)复制
(2)Sentinel
(3)集群
第四部分、独立功能的实现
(1)发布与订阅
(2)事务
(3)Lua脚本
(4)排序
(5)二进制位数组
(6)慢查询日志
(7)监视器